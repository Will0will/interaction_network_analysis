col = col_for_cluster[cluster_results],
bty = "n",
pch=20 ,
pt.cex = 1.5,
cex = 0.75,
text.col = col_for_cluster[cluster_results] ,
horiz = FALSE,
inset = c(0.1, 0.1))
g_membership <- g_community$membership
cluster_results
enrichment_fisher_test_mass_apply <- function(cluster_vec, annotations_vec){
ft_res <- NULL
# annotations_set = universe_labels
# cluster_set = mapped_membership
for (annotation in unique(annotations_vec)) {
row <- sapply(unique(cluster_vec), function(cluster){
enrichment_fisher_test(cluster_vec, annotations_vec, cluster, annotation)
})
ft_res <- rbind(ft_res, unlist(row))
}
row.names(ft_res) <- unique(annotations_vec)
colnames(ft_res) <- paste0("cluster_", unique(cluster_vec))
return(as.data.frame(ft_res))
}
g_membership <- g_community$membership
universe_labels <- kegg_annotation_nodes$pw_des
mapped_membership <- map_a_to_b(a = g_membership,
ind_a = vertex_names,
ind_b = kegg_annotation_nodes$protein_ids)
# remove the NAs in the list
mapped_membership <- mapped_membership[!is.na(universe_labels)]
universe_labels <- universe_labels[!is.na(universe_labels)]
table(universe_labels)[order(table(universe_labels), decreasing = T)]
# carry out enrichment analysis
ft_res <- enrichment_fisher_test_mass_apply(universe_labels, mapped_membership)
p_adj_res <- ft_res
p_adj_res[,] <- p.adjust(unlist(p_adj_res), method = "BH")
# the results:
cluster_results <- which(p_adj_res < 0.05, arr.ind = T)[, 2]
cluster_results <- cluster_results[names(cluster_results) != "Metabolic pathways"]
# plot:
#  generate the colors
color_size <- length(unique(g_membership))
col_for_cluster <- color_generator(color_size)
# shapes of the node:
shape_pos <- vertex_names %in% links$tar_proteins
v_shapes <- c("circle",  "square")[shape_pos+1] # target-square; potential-circle.
# visualization
plot(g, vertex.shape = v_shapes,
vertex.color=col_for_cluster[g_membership],
vertex.size = 7,
vertex.label=NA)
legend("topleft",
legend= names(cluster_results),
col = col_for_cluster[cluster_results],
bty = "n",
pch=20 ,
pt.cex = 1.5,
cex = 0.75,
text.col = col_for_cluster[cluster_results] ,
horiz = FALSE,
inset = c(0.1, 0.1))
ft_res
enrichment_fisher_test_mass_apply <- function(cluster_vec, annotations_vec){
ft_res <- NULL
# annotations_set = universe_labels
# cluster_set = mapped_membership
for (annotation in unique(annotations_vec)) {
row <- sapply(unique(cluster_vec), function(cluster){
enrichment_fisher_test(cluster_vec, annotations_vec, cluster, annotation)
})
ft_res <- rbind(ft_res, unlist(row))
}
row.names(ft_res) <- unique(annotations_vec)
colnames(ft_res) <- paste0("cluster_", unique(cluster_vec))
return(as.data.frame(ft_res))
}
g_membership <- g_community$membership
universe_labels <- kegg_annotation_nodes$pw_des
mapped_membership <- map_a_to_b(a = g_membership,
ind_a = vertex_names,
ind_b = kegg_annotation_nodes$protein_ids)
# remove the NAs in the list
mapped_membership <- mapped_membership[!is.na(universe_labels)]
universe_labels <- universe_labels[!is.na(universe_labels)]
table(universe_labels)[order(table(universe_labels), decreasing = T)]
# carry out enrichment analysis
ft_res <- enrichment_fisher_test_mass_apply(mapped_membership, universe_labels)
p_adj_res <- ft_res
p_adj_res[,] <- p.adjust(unlist(p_adj_res), method = "BH")
# the results:
cluster_results <- which(p_adj_res < 0.05, arr.ind = T)[, 2]
cluster_results <- cluster_results[names(cluster_results) != "Metabolic pathways"]
# plot:
#  generate the colors
color_size <- length(unique(g_membership))
col_for_cluster <- color_generator(color_size)
# shapes of the node:
shape_pos <- vertex_names %in% links$tar_proteins
v_shapes <- c("circle",  "square")[shape_pos+1] # target-square; potential-circle.
# visualization
plot(g, vertex.shape = v_shapes,
vertex.color=col_for_cluster[g_membership],
vertex.size = 7,
vertex.label=NA)
legend("topleft",
legend= names(cluster_results),
col = col_for_cluster[cluster_results],
bty = "n",
pch=20 ,
pt.cex = 1.5,
cex = 0.75,
text.col = col_for_cluster[cluster_results] ,
horiz = FALSE,
inset = c(0.1, 0.1))
g_membership <- g_community$membership
universe_labels <- go_annotation_nodes$go_terms
mapped_membership <- map_a_to_b(a = g_membership,
ind_a = vertex_names,
ind_b = go_annotation_nodes$protein_ids)
# remove the NAs in the list
mapped_membership <- mapped_membership[!is.na(universe_labels)]
universe_labels <- universe_labels[!is.na(universe_labels)]
table(universe_labels)[order(table(universe_labels), decreasing = T)]
# carry out enrichment analysis
ft_res <- enrichment_fisher_test_mass_apply(mapped_membership, universe_labels)
# the results:
row.names(ft_res) <- unique(universe_labels)
colnames(ft_res) <- paste0("cluster_", unique(mapped_membership))
p_adj_res <- ft_res
p_adj_res[,] <- p.adjust(unlist(p_adj_res), method = "BH")
# the results:
cluster_results <- which(p_adj_res < 0.05, arr.ind = T)[, 2]
# go enrich visualiztion:
p_for_cluster_1 <- p_adj_res[,1]
top_20_sig_gos <- p_for_cluster_1[order(p_for_cluster_1, decreasing = F)][1:20]
go_terms_for_networking <- names(top_20_sig_gos)
go_URIs <- paste0("oboGo:", gsub(":", "_" ,go_terms_for_networking))
go_enrich_visualiztion <- data_require(GO_hierarchy_retrival_query_make, list(go_URIs), endpoint)
g_go_hierachy <- graph_from_data_frame(d = go_enrich_visualiztion, directed = F)
plot(g_go_hierachy)
functional_anno <- unip_annotation_nodes[unip_annotation_nodes$types == "Function_Annotation", ]
betw_centralities <- map_a_to_b(betw_centralities, names(betw_centralities), vertex_names)
btwness <- as.numeric(betw_centralities)*100
btwness[btwness < 1] <- 0.1
functional_anno <- map_a_to_b(a = functional_anno, ind_a = functional_anno$protein_ids, ind_b = vertex_names)
annotation <- tubular_paste(list(vertex_names, functional_anno$comments))
nodes <- cbind.data.frame(vertex_names,  group = g_membership, annotation = annotation, btwness)
# make the links
links <- interactions[, c(1, 2, 4)][interactions$weights > cutoff, ]
links$pot_proteins <- match(links$pot_proteins, vertex_names) - 1
links$tar_proteins <- match(links$tar_proteins, vertex_names) - 1
links$weights <- links$weights / 200
# set the calls for forceNetwork
calls <- list(
# data frame inputs
Links = links,  # linkage dataframe
Nodes = nodes,  # the characters of the nodes
# explanatory inputs:
Source = "pot_proteins",  # source of the linkages
Target = "tar_proteins",  #  targets of the linkages
Value = "weights",  # thickness of the edges in the graph
NodeID = "annotation",  # text shown in the nodes
Group = "group",  # groups of the nodes
Nodesize = "btwness" ,
# aesthetics inputs:
fontFamily="Arial",
fontSize = 10,
linkColour="black",
# colourScale,
# linkWidth,
charge = -13, # how strong the nodes should gather or repel to each other
opacity = 0.9,
legend=T,
arrows=T,
bounded=F,  # whether turn on the boundaries for the plots
# opacityNoHover=10, # the degree of opacity when the mouse is not suspending on the nodes
zoom = T  # allow zoom(double click to )
)
# change the default setting
# calls["NodeID"] <- "vertex_names"
test <- do.call(what = forceNetwork, args = calls)
test
clear()
clear
clearPushBack()
unip_annotation_nodes
vertex_names
length(vertex_names)
table(unip_annotation_nodes$types)[order(table(unip_annotation_nodes$types))]
# make the nodes
functional_anno <- unip_annotation_nodes[unip_annotation_nodes$types == "Function_Annotation", ]
betw_centralities <- map_a_to_b(betw_centralities, names(betw_centralities), vertex_names)
btwness <- as.numeric(betw_centralities)*100
btwness[btwness < 1] <- 0.1
functional_anno <- map_a_to_b(a = functional_anno, ind_a = functional_anno$protein_ids, ind_b = vertex_names)
annotation <- tubular_paste(list(vertex_names, functional_anno$comments))
nodes <- cbind.data.frame(vertex_names,  group = g_membership, annotation = annotation, btwness)
# make the links
links <- interactions[, c(1, 2, 4)][interactions$weights > cutoff, ]
links$pot_proteins <- match(links$pot_proteins, vertex_names) - 1
links$tar_proteins <- match(links$tar_proteins, vertex_names) - 1
links$weights <- links$weights / 200
# set the calls for forceNetwork
calls <- list(
# data frame inputs
Links = links,  # linkage dataframe
Nodes = nodes,  # the characters of the nodes
# explanatory inputs:
Source = "pot_proteins",  # source of the linkages
Target = "tar_proteins",  #  targets of the linkages
Value = "weights",  # thickness of the edges in the graph
NodeID = "annotation",  # text shown in the nodes
Group = "group",  # groups of the nodes
Nodesize = "btwness" ,
# aesthetics inputs:
fontFamily="Arial",
fontSize = 10,
linkColour="black",
# colourScale,
# linkWidth,
charge = -13, # how strong the nodes should gather or repel to each other
opacity = 0.9,
legend=T,
arrows=T,
bounded=F,  # whether turn on the boundaries for the plots
# opacityNoHover=10, # the degree of opacity when the mouse is not suspending on the nodes
zoom = T  # allow zoom(double click to )
)
# change the default setting
# calls["NodeID"] <- "vertex_names"
test <- do.call(what = forceNetwork, args = calls)
test
# Calculate the betweeness centrality
betw_centralities <- betweenness(g, v = V(g), directed = F, weights = NULL, normalized = T)
betw_centralities <- betw_centralities[order(betw_centralities, decreasing = T)]
# make the nodes
functional_anno <- unip_annotation_nodes[unip_annotation_nodes$types == "Function_Annotation", ]
betw_centralities <- map_a_to_b(betw_centralities, names(betw_centralities), vertex_names)
btwness <- as.numeric(betw_centralities)*100
btwness[btwness < 1] <- 0.1
functional_anno <- map_a_to_b(a = functional_anno, ind_a = functional_anno$protein_ids, ind_b = vertex_names)
annotation <- tubular_paste(list(vertex_names, functional_anno$comments))
nodes <- cbind.data.frame(vertex_names,  group = g_membership, annotation = annotation, btwness)
# make the links
links <- interactions[, c(1, 2, 4)][interactions$weights > cutoff, ]
links$pot_proteins <- match(links$pot_proteins, vertex_names) - 1
links$tar_proteins <- match(links$tar_proteins, vertex_names) - 1
links$weights <- links$weights / 200
# set the calls for forceNetwork
calls <- list(
# data frame inputs
Links = links,  # linkage dataframe
Nodes = nodes,  # the characters of the nodes
# explanatory inputs:
Source = "pot_proteins",  # source of the linkages
Target = "tar_proteins",  #  targets of the linkages
Value = "weights",  # thickness of the edges in the graph
NodeID = "annotation",  # text shown in the nodes
Group = "group",  # groups of the nodes
Nodesize = "btwness" ,
# aesthetics inputs:
fontFamily="Arial",
fontSize = 10,
linkColour="black",
# colourScale,
# linkWidth,
charge = -13, # how strong the nodes should gather or repel to each other
opacity = 0.9,
legend=T,
arrows=T,
bounded=F,  # whether turn on the boundaries for the plots
# opacityNoHover=10, # the degree of opacity when the mouse is not suspending on the nodes
zoom = T  # allow zoom(double click to )
)
# change the default setting
# calls["NodeID"] <- "vertex_names"
test <- do.call(what = forceNetwork, args = calls)
test
library(networkD3)
library(htmlwidgets)
tubular_paste <- function(lists_of_tubulars, separation = "; ") {
paste_df <- as.data.frame(lists_of_tubulars)
results <- do.call(paste, c(paste_df, sep= separation))
return(results)
}
unip_annotation_nodes
vertex_names
tubular_paste <- function(lists_of_tubulars, separation = "; ") {
paste_df <- as.data.frame(lists_of_tubulars)
results <- do.call(paste, c(paste_df, sep= separation))
return(results)
}
unip_annotation_nodes
vertex_names
length(vertex_names)
table(unip_annotation_nodes$types)[order(table(unip_annotation_nodes$types))]
# make the nodes
functional_anno <- unip_annotation_nodes[unip_annotation_nodes$types == "Function_Annotation", ]
betw_centralities <- map_a_to_b(betw_centralities, names(betw_centralities), vertex_names)
btwness <- as.numeric(betw_centralities)*100
btwness[btwness < 1] <- 0.1
functional_anno <- map_a_to_b(a = functional_anno, ind_a = functional_anno$protein_ids, ind_b = vertex_names)
annotation <- tubular_paste(list(vertex_names, functional_anno$comments))
nodes <- cbind.data.frame(vertex_names,  group = g_membership, annotation = annotation, btwness)
# make the links
links <- interactions[, c(1, 2, 4)][interactions$weights > cutoff, ]
links$pot_proteins <- match(links$pot_proteins, vertex_names) - 1
links$tar_proteins <- match(links$tar_proteins, vertex_names) - 1
links$weights <- links$weights / 200
# set the calls for forceNetwork
calls <- list(
# data frame inputs
Links = links,  # linkage dataframe
Nodes = nodes,  # the characters of the nodes
# explanatory inputs:
Source = "pot_proteins",  # source of the linkages
Target = "tar_proteins",  #  targets of the linkages
Value = "weights",  # thickness of the edges in the graph
NodeID = "annotation",  # text shown in the nodes
Group = "group",  # groups of the nodes
Nodesize = "btwness" ,
# aesthetics inputs:
fontFamily="Arial",
fontSize = 10,
linkColour="black",
# colourScale,
# linkWidth,
charge = -13, # how strong the nodes should gather or repel to each other
opacity = 0.9,
legend=T,
arrows=T,
bounded=F,  # whether turn on the boundaries for the plots
# opacityNoHover=10, # the degree of opacity when the mouse is not suspending on the nodes
zoom = T  # allow zoom(double click to )
)
# change the default setting
# calls["NodeID"] <- "vertex_names"
test <- do.call(what = forceNetwork, args = calls)
test
# go enrich visualiztion:
p_for_cluster_1 <- p_adj_res[,2]
top_20_sig_gos <- p_for_cluster_1[order(p_for_cluster_1, decreasing = F)][1:20]
go_terms_for_networking <- names(top_20_sig_gos)
go_URIs <- paste0("oboGo:", gsub(":", "_" ,go_terms_for_networking))
go_enrich_visualiztion <- data_require(GO_hierarchy_retrival_query_make, list(go_URIs), endpoint)
g_go_hierachy <- graph_from_data_frame(d = go_enrich_visualiztion, directed = F)
plot(g_go_hierachy)
go_enrich_visualiztion
go_URIs
p_for_cluster_1
# go enrich visualiztion:
p_for_cluster_1 <- p_adj_res[,2]
p_for_cluster_1
top_20_sig_gos <- p_for_cluster_1[order(p_for_cluster_1, decreasing = F)][1:20]
top_20_sig_gos
go_terms_for_networking <- names(top_20_sig_gos)
go_terms_for_networking
p_adj_res
p_adj_res[,2]
p_adj_res[,1]
cluster_results
# go enrich visualiztion:
p_for_cluster_1 <- p_adj_res[,1]
top_20_sig_gos <- p_for_cluster_1[order(p_for_cluster_1, decreasing = F)][1:20]
go_terms_for_networking <- names(top_20_sig_gos)
go_URIs <- paste0("oboGo:", gsub(":", "_" ,go_terms_for_networking))
go_terms_for_networking
# go enrich visualiztion:
p_for_cluster_1 <- p_adj_res[,1]
top_20_sig_gos <- row.names(p_adj_res)[order(p_for_cluster_1, decreasing = F)][1:20]
top_20_sig_gos
go_URIs <- paste0("oboGo:", gsub(":", "_" ,top_20_sig_gos))
go_enrich_visualiztion <- data_require(GO_hierarchy_retrival_query_make, list(go_URIs), endpoint)
g_go_hierachy <- graph_from_data_frame(d = go_enrich_visualiztion, directed = F)
plot(g_go_hierachy)
# go enrich visualiztion:
p_for_cluster_1 <- p_adj_res[,2]
top_20_sig_gos <- row.names(p_adj_res)[order(p_for_cluster_1, decreasing = F)][1:20]
go_URIs <- paste0("oboGo:", gsub(":", "_" ,top_20_sig_gos))
go_enrich_visualiztion <- data_require(GO_hierarchy_retrival_query_make, list(go_URIs), endpoint)
g_go_hierachy <- graph_from_data_frame(d = go_enrich_visualiztion, directed = F)
plot(g_go_hierachy)
topological.sort(g_go_hierachy)
GO_hierarchy_retrival_query_make <- function(go_URIs) {
values <- paste0(go_URIs, collapse = " ")
query <- paste0("prefix obo: <http://purl.obolibrary.org/obo/>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix term: <http://rdf.ebi.ac.uk/terms/ensembl/>
prefix dc: <http://purl.org/dc/elements/1.1/>
prefix core: <http://purl.uniprot.org/core/>
prefix protein: <http://rdf.ebi.ac.uk/resource/ensembl.protein/>
prefix goFormat: <http://www.geneontology.org/formats/oboInOwl#>
prefix oboGo: <http://purl.obolibrary.org/obo/>
SELECT DISTINCT ?from_go_terms ?to_go_terms
WHERE{
VALUES ?go_from { ", values , " }
VALUES ?go_to {",  values ,"}
?go_from rdfs:subClassOf ?go_offsprings .
?go_from goFormat:id ?from_go_terms .
?go_to goFormat:id ?to_go_terms .
filter(?go_to = ?go_offsprings)
}")
return(query)
}
go_URIs <- paste0("oboGo:", gsub(":", "_" ,top_20_sig_gos))
go_enrich_visualiztion <- data_require(GO_hierarchy_retrival_query_make, list(go_URIs), endpoint)
g_go_hierachy <- graph_from_data_frame(d = go_enrich_visualiztion, directed = F)
plot(g_go_hierachy)
g_go_hierachy <- graph_from_data_frame(d = go_enrich_visualiztion, directed = T)
plot(g_go_hierachy)
topological.sort(g_go_hierachy)
plot(topological.sort(g_go_hierachy))
topological.sort(g_go_hierachy)
plot(g_go_hierachy)
go_enrich_visualiztion
plot(get.shortest.paths(g_go_hierachy))
plot(minimum.spanning.tree(g_go_hierachy))
g_go_hierachy
go_enrich_visualiztion
cluster_results
p_adj_res
go_annotation_nodes
GO_hierarchy_retrival_query_make <- function(go_URIs) {
values <- paste0(go_URIs, collapse = " ")
query <- paste0("prefix obo: <http://purl.obolibrary.org/obo/>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix term: <http://rdf.ebi.ac.uk/terms/ensembl/>
prefix dc: <http://purl.org/dc/elements/1.1/>
prefix core: <http://purl.uniprot.org/core/>
prefix protein: <http://rdf.ebi.ac.uk/resource/ensembl.protein/>
prefix goFormat: <http://www.geneontology.org/formats/oboInOwl#>
prefix oboGo: <http://purl.obolibrary.org/obo/>
SELECT DISTINCT ?from_go_terms ?form_go_descrips ?to_go_terms ?to_go_descrips
WHERE{
VALUES ?go_from { ", values , " }
VALUES ?go_to {",  values ,"}
?go_from rdfs:subClassOf ?go_offsprings .
?go_from goFormat:id ?from_go_terms ;
rdfs:label ?form_go_descrips .
?go_to goFormat:id ?to_go_terms ;
rdfs:label ?to_go_descrips .
filter(?go_to = ?go_offsprings)
}")
return(query)
}
go_URIs <- paste0("oboGo:", gsub(":", "_" ,top_20_sig_gos))
go_enrich_visualiztion <- data_require(GO_hierarchy_retrival_query_make, list(go_URIs), endpoint)
go_enrich_visualiztion
paste0(go_enrich_visualiztion[, 1], go_enrich_visualiztion[, 2], sep = "\n" )
paste(go_enrich_visualiztion[, 1], go_enrich_visualiztion[, 2], sep = "\n" )
links <- cbind.data.frame(from = paste(go_enrich_visualiztion[, 1], go_enrich_visualiztion[, 2], sep = "\n" ),
to = paste(go_enrich_visualiztion[, 3], go_enrich_visualiztion[, 4], sep = "\n" ))
g_go_hierachy <- graph_from_data_frame(d = links, directed = T)
plot(g_go_hierachy)
plot(minimum.spanning.tree(g_go_hierachy))
plot(minimum.spanning.tree(g_go_hierachy))
colors <- colorRampPalette(c("red", "white"))(5)
colors
V(g_go_hierachy)
V(g_go_hierachy)$name
top_20_sig_gos
colors
colors <- colorRampPalette(c("red", "white"))(5)
apply(colors, function(x) {
rep(x, 5)
})
sapply(colors, function(x) {
rep(x, 5)
})
unlist(sapply(colors, function(x) {
rep(x, 5)
}))
unlist(sapply(colors, function(x) {
rep(x, 5)
}))
sapply(colors, function(x) {
res <- NULL
res <- c(res, rep(x, 5))
})
a <- sapply(colors, function(x) {
rep(x, 5)
})
unlist(a)
unlist(a, use.names = F)
reduce( c, sapply(colors, function(x) {
rep(x, 5)
}))
Reduce(c, sapply(colors, function(x) {
rep(x, 5)
}))
gredients <- Reduce(c, sapply(colors, function(x) {
rep(x, 5)
}))
V(g_go_hierachy)$name
gsub("\n.*", "", V(g_go_hierachy)$name)
match(gsub("\n.*", "", V(g_go_hierachy)$name), top_20_sig_gos)
V(g_go_hierachy)$name)
V(g_go_hierachy)$name
gsub("\n.*", "", V(g_go_hierachy)$name)
top_20_sig_gos
match(gsub("\n.*", "", V(g_go_hierachy)$name), top_20_sig_gos)
gredients[match(top_20_sig_gos, gsub("\n.*", "", V(g_go_hierachy)$name))]
gredients<- gredients[match(top_20_sig_gos, gsub("\n.*", "", V(g_go_hierachy)$name))]
plot(minimum.spanning.tree(g_go_hierachy), vertex.color = gredients)
colors <- colorRampPalette(c("orange", "white"))(5)
colors
gredients <- Reduce(c, sapply(colors, function(x) {
rep(x, 5)
}))
gredients <- gredients[match(top_20_sig_gos, gsub("\n.*", "", V(g_go_hierachy)$name))]
plot(minimum.spanning.tree(g_go_hierachy), vertex.color = gredients)
